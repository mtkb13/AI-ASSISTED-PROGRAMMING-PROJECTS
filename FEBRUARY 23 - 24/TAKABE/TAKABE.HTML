<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Beam Shear & Moment Diagram</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Segoe UI', sans-serif; background: #0f1117; color: #e0e0e0; min-height: 100vh; }
  
  header {
    background: linear-gradient(135deg, #1a1d2e, #252840);
    padding: 20px 30px;
    border-bottom: 1px solid #3a3f6e;
    display: flex; align-items: center; gap: 16px;
  }
  header h1 { font-size: 1.4rem; font-weight: 600; color: #a0aaff; }
  header p { font-size: 0.8rem; color: #666; margin-top: 2px; }

  .container { display: grid; grid-template-columns: 340px 1fr; gap: 0; min-height: calc(100vh - 70px); }

  .sidebar {
    background: #13151f;
    border-right: 1px solid #252840;
    padding: 20px;
    overflow-y: auto;
  }
  
  .section { margin-bottom: 20px; }
  .section-title {
    font-size: 0.7rem; font-weight: 700; text-transform: uppercase;
    letter-spacing: 1px; color: #666; margin-bottom: 12px;
    padding-bottom: 8px; border-bottom: 1px solid #252840;
  }

  label { display: block; font-size: 0.78rem; color: #aaa; margin-bottom: 4px; }
  input, select {
    width: 100%; padding: 7px 10px; background: #1e2130;
    border: 1px solid #2e3352; border-radius: 6px;
    color: #e0e0e0; font-size: 0.82rem; margin-bottom: 10px;
    outline: none; transition: border-color 0.2s;
  }
  input:focus, select:focus { border-color: #5b6fff; }

  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }

  .btn {
    width: 100%; padding: 9px; border: none; border-radius: 6px;
    font-size: 0.82rem; font-weight: 600; cursor: pointer;
    transition: all 0.2s; letter-spacing: 0.3px;
  }
  .btn-primary { background: #4f5fff; color: #fff; }
  .btn-primary:hover { background: #6270ff; }
  .btn-danger { background: #ff4f5a; color: #fff; margin-top: 6px; }
  .btn-danger:hover { background: #ff6070; }
  .btn-success { background: #2ecc71; color: #fff; margin-bottom: 10px; }
  .btn-success:hover { background: #3ddd82; }
  .btn-outline {
    background: transparent; border: 1px solid #3a3f6e;
    color: #aaa; margin-top: 6px;
  }
  .btn-outline:hover { border-color: #5b6fff; color: #a0aaff; }

  .load-list { margin-bottom: 10px; }
  .load-item {
    background: #1e2130; border: 1px solid #2e3352;
    border-radius: 6px; padding: 8px 10px; margin-bottom: 6px;
    display: flex; justify-content: space-between; align-items: center;
    font-size: 0.78rem;
  }
  .load-item .del { color: #ff4f5a; cursor: pointer; font-size: 1rem; line-height: 1; }
  .load-item .del:hover { color: #ff7080; }
  .load-label { color: #7090ff; font-weight: 600; margin-right: 6px; }
  .load-detail { color: #aaa; }

  .support-row {
    background: #1e2130; border: 1px solid #2e3352;
    border-radius: 6px; padding: 10px; margin-bottom: 8px;
  }
  .support-row label { color: #aaa; font-size: 0.75rem; }

  .main { display: flex; flex-direction: column; padding: 20px; gap: 16px; background: #0f1117; }

  canvas {
    background: #13151f; border: 1px solid #252840;
    border-radius: 10px; display: block;
  }
  .canvas-title {
    font-size: 0.72rem; font-weight: 700; text-transform: uppercase;
    letter-spacing: 1px; color: #666; margin-bottom: 6px;
  }

  .results-grid {
    display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;
  }
  .result-card {
    background: #13151f; border: 1px solid #252840;
    border-radius: 8px; padding: 14px; text-align: center;
  }
  .result-card .val { font-size: 1.3rem; font-weight: 700; color: #a0aaff; }
  .result-card .lbl { font-size: 0.7rem; color: #666; margin-top: 4px; }

  .error { color: #ff6070; font-size: 0.78rem; padding: 6px; background: #2a1520; border-radius: 4px; margin-top: 6px; }
  .info { color: #70aaff; font-size: 0.75rem; margin-top: 4px; }

  .legend { display: flex; gap: 16px; flex-wrap: wrap; padding: 8px 0; }
  .legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.75rem; color: #aaa; }
  .legend-color { width: 24px; height: 3px; border-radius: 2px; }

  #spans-container .span-row {
    display: flex; gap: 6px; align-items: center; margin-bottom: 6px;
  }
  #spans-container .span-row input { margin-bottom: 0; flex: 1; }
  #spans-container .span-row label { margin: 0; white-space: nowrap; min-width: 50px; }
</style>
</head>
<body>

<header>
  <div>
    <h1>⚡ Beam Analysis — Shear & Moment Diagrams</h1>
    <p>Multi-span beams with point loads and uniform distributed loads</p>
  </div>
</header>

<div class="container">
  <!-- SIDEBAR -->
  <div class="sidebar">

    <!-- SPANS -->
    <div class="section">
      <div class="section-title">Beam Spans</div>
      <div id="spans-container"></div>
      <div class="row">
        <button class="btn btn-outline" onclick="addSpan()">+ Add Span</button>
        <button class="btn btn-outline" onclick="removeSpan()">− Remove Span</button>
      </div>
    </div>

    <!-- SUPPORTS -->
    <div class="section">
      <div class="section-title">Supports</div>
      <div id="supports-container"></div>
      <p class="info">Supports are placed at span junctions automatically.</p>
    </div>

    <!-- POINT LOADS -->
    <div class="section">
      <div class="section-title">Point Loads</div>
      <div class="row3">
        <div>
          <label>Position (m)</label>
          <input type="number" id="pl-pos" value="2" step="0.1">
        </div>
        <div>
          <label>Force (kN)</label>
          <input type="number" id="pl-force" value="10" step="1">
        </div>
        <div>
          <label>Direction</label>
          <select id="pl-dir">
            <option value="-1">↓ Down</option>
            <option value="1">↑ Up</option>
          </select>
        </div>
      </div>
      <button class="btn btn-primary" onclick="addPointLoad()">Add Point Load</button>
      <div class="load-list" id="pl-list"></div>
    </div>

    <!-- UDL -->
    <div class="section">
      <div class="section-title">Uniform Distributed Loads</div>
      <div class="row">
        <div>
          <label>Start (m)</label>
          <input type="number" id="udl-start" value="0" step="0.1">
        </div>
        <div>
          <label>End (m)</label>
          <input type="number" id="udl-end" value="4" step="0.1">
        </div>
      </div>
      <div class="row">
        <div>
          <label>Intensity (kN/m)</label>
          <input type="number" id="udl-w" value="5" step="0.5">
        </div>
        <div>
          <label>Direction</label>
          <select id="udl-dir">
            <option value="-1">↓ Down</option>
            <option value="1">↑ Up</option>
          </select>
        </div>
      </div>
      <button class="btn btn-primary" onclick="addUDL()">Add UDL</button>
      <div class="load-list" id="udl-list"></div>
    </div>

    <!-- ANALYZE -->
    <div class="section">
      <button class="btn btn-success" onclick="analyze()">▶ Analyze Beam</button>
      <button class="btn btn-danger" onclick="resetAll()">✕ Reset All</button>
      <div id="error-box"></div>
    </div>

  </div>

  <!-- MAIN -->
  <div class="main">
    <div class="results-grid" id="results-grid">
      <div class="result-card"><div class="val" id="res-rl">—</div><div class="lbl">Max Reaction (kN)</div></div>
      <div class="result-card"><div class="val" id="res-vs">—</div><div class="lbl">Max Shear (kN)</div></div>
      <div class="result-card"><div class="val" id="res-ms">—</div><div class="lbl">Max Moment (kN·m)</div></div>
      <div class="result-card"><div class="val" id="res-tl">—</div><div class="lbl">Total Load (kN)</div></div>
    </div>

    <div>
      <div class="canvas-title">Beam Diagram</div>
      <canvas id="beamCanvas" height="130"></canvas>
    </div>

    <div>
      <div class="canvas-title">Shear Force Diagram (SFD)</div>
      <canvas id="sfdCanvas" height="200"></canvas>
    </div>

    <div>
      <div class="canvas-title">Bending Moment Diagram (BMD)</div>
      <canvas id="bmdCanvas" height="200"></canvas>
    </div>

    <div class="legend">
      <div class="legend-item"><div class="legend-color" style="background:#4f9fff"></div>Beam</div>
      <div class="legend-item"><div class="legend-color" style="background:#ff6b3d"></div>Shear Force</div>
      <div class="legend-item"><div class="legend-color" style="background:#2ecc71"></div>Bending Moment</div>
      <div class="legend-item"><div class="legend-color" style="background:#f0c040"></div>Point Load</div>
      <div class="legend-item"><div class="legend-color" style="background:#cc70ff"></div>UDL</div>
    </div>
  </div>
</div>

<script>
// ─── State ───────────────────────────────────────────────────────────────────
let spans = [4, 4];           // span lengths in m
let supportTypes = [];         // 'pin', 'roller', 'fixed' for each support
let pointLoads = [];           // {pos, force, dir}
let udls = [];                 // {start, end, w, dir}

// ─── Init ────────────────────────────────────────────────────────────────────
function init() {
  renderSpans();
  analyze();
}

function renderSpans() {
  const c = document.getElementById('spans-container');
  c.innerHTML = '';
  spans.forEach((s, i) => {
    const row = document.createElement('div');
    row.className = 'span-row';
    row.innerHTML = `<label>Span ${i+1}</label>
      <input type="number" value="${s}" min="0.1" step="0.1"
        onchange="spans[${i}]=parseFloat(this.value)||1; renderSupports();">
      <span style="color:#666;font-size:0.75rem">m</span>`;
    c.appendChild(row);
  });
  renderSupports();
}

function addSpan() {
  spans.push(4);
  renderSpans();
}
function removeSpan() {
  if (spans.length > 1) { spans.pop(); renderSpans(); }
}

function renderSupports() {
  const numSupports = spans.length + 1;
  // Grow or shrink supportTypes
  while (supportTypes.length < numSupports) {
    const i = supportTypes.length;
    supportTypes.push(i === 0 ? 'pin' : (i === numSupports - 1 ? 'roller' : 'roller'));
  }
  supportTypes.length = numSupports;

  const c = document.getElementById('supports-container');
  c.innerHTML = '';
  const totalL = spans.reduce((a,b)=>a+b,0);
  let positions = [0];
  let cum = 0;
  for (let s of spans) { cum += s; positions.push(cum); }

  supportTypes.forEach((type, i) => {
    const row = document.createElement('div');
    row.className = 'support-row';
    row.innerHTML = `<label>Support ${i+1} @ x=${positions[i].toFixed(2)}m</label>
      <select onchange="supportTypes[${i}]=this.value">
        <option value="pin" ${type==='pin'?'selected':''}>Pin (Hinge)</option>
        <option value="roller" ${type==='roller'?'selected':''}>Roller</option>
        <option value="fixed" ${type==='fixed'?'selected':''}>Fixed (Wall)</option>
        <option value="none" ${type==='none'?'selected':''}>None (Internal)</option>
      </select>`;
    c.appendChild(row);
  });
}

// ─── Load Management ─────────────────────────────────────────────────────────
function addPointLoad() {
  const pos = parseFloat(document.getElementById('pl-pos').value);
  const force = parseFloat(document.getElementById('pl-force').value);
  const dir = parseInt(document.getElementById('pl-dir').value);
  if (isNaN(pos) || isNaN(force)) return;
  pointLoads.push({pos, force: force * dir});
  renderLists();
}

function addUDL() {
  const start = parseFloat(document.getElementById('udl-start').value);
  const end = parseFloat(document.getElementById('udl-end').value);
  const w = parseFloat(document.getElementById('udl-w').value);
  const dir = parseInt(document.getElementById('udl-dir').value);
  if (isNaN(start)||isNaN(end)||isNaN(w)||start>=end) return;
  udls.push({start, end, w: w * dir});
  renderLists();
}

function renderLists() {
  const plList = document.getElementById('pl-list');
  plList.innerHTML = pointLoads.map((pl, i) =>
    `<div class="load-item">
      <span><span class="load-label">P${i+1}</span>
      <span class="load-detail">${pl.force>0?'↑':'↓'} |${Math.abs(pl.force)}| kN @ x=${pl.pos}m</span></span>
      <span class="del" onclick="pointLoads.splice(${i},1);renderLists()">✕</span>
    </div>`).join('');

  const udlList = document.getElementById('udl-list');
  udlList.innerHTML = udls.map((u, i) =>
    `<div class="load-item">
      <span><span class="load-label">W${i+1}</span>
      <span class="load-detail">${u.w>0?'↑':'↓'} |${Math.abs(u.w)}| kN/m [${u.start}–${u.end}m]</span></span>
      <span class="del" onclick="udls.splice(${i},1);renderLists()">✕</span>
    </div>`).join('');
}

// ─── Analysis Engine ──────────────────────────────────────────────────────────
function analyze() {
  document.getElementById('error-box').innerHTML = '';
  const totalL = spans.reduce((a,b)=>a+b,0);
  if (totalL <= 0) return;

  // Positions of all supports
  let supPos = [0];
  let cum = 0;
  for (let s of spans) { cum += s; supPos.push(cum); }
  
  // Filter active supports (not 'none')
  const activeSupports = supPos.map((x,i) => ({x, type: supportTypes[i]}))
                                .filter(s => s.type !== 'none');

  // Count unknowns: pin/fixed = 2 (V+H), roller = 1 (V), fixed end = 3 (V+H+M)
  // For simplicity: treat as simply supported / statically determinate or use
  // force method for continuous beams.
  
  // We'll solve using the three-moment equation (Clapeyron) for continuous beams
  // or direct statics for simply supported.
  
  const reactions = solveReactions(totalL, supPos, activeSupports);
  if (!reactions) {
    showError('Cannot solve: check support configuration.');
    return;
  }

  // Build SFD/BMD by numerical integration
  const N = 2000;
  const dx = totalL / N;
  const x = Array.from({length: N+1}, (_,i) => i * dx);

  // Load intensity function (distributed)
  function w(xi) {
    let total = 0;
    for (const u of udls) {
      if (xi >= u.start && xi <= u.end) total += u.w;
    }
    return total; // positive = up
  }

  // Build shear by integrating from left
  const V = new Float64Array(N+1);
  const M = new Float64Array(N+1);

  // Start shear = 0
  // Apply reactions and loads
  V[0] = 0;
  // Add any reaction at x=0
  for (const r of reactions) {
    if (Math.abs(r.x) < 1e-9) V[0] += r.Ry;
  }
  // Add any point load at x=0
  for (const pl of pointLoads) {
    if (Math.abs(pl.pos) < 1e-9) V[0] += pl.force; // force positive = up
  }

  for (let i = 0; i < N; i++) {
    const xi = x[i];
    const xi1 = x[i+1];
    // Shear at i+1 = shear at i + distributed loads in interval + point reactions/loads at xi1
    V[i+1] = V[i] + w(xi + dx/2) * dx;
    // Add reactions exactly at xi1
    for (const r of reactions) {
      if (r.x > xi && r.x <= xi1 + 1e-9 && Math.abs(r.x - xi1) < dx*0.6) V[i+1] += r.Ry;
    }
    // Add point loads at xi1
    for (const pl of pointLoads) {
      if (pl.pos > xi && pl.pos <= xi1 + 1e-9 && Math.abs(pl.pos - xi1) < dx*0.6) V[i+1] += pl.force;
    }
  }

  // Bending moment by trapezoidal integration of shear
  M[0] = 0;
  // Check for fixed moment at left support
  for (const r of reactions) {
    if (Math.abs(r.x) < 1e-9 && r.Mz !== undefined) M[0] += r.Mz;
  }

  for (let i = 0; i < N; i++) {
    M[i+1] = M[i] + (V[i] + V[i+1]) / 2 * dx;
  }

  // Stats
  let maxV = 0, maxM = 0, maxR = 0;
  for (let i = 0; i <= N; i++) {
    if (Math.abs(V[i]) > maxV) maxV = Math.abs(V[i]);
    if (Math.abs(M[i]) > maxM) maxM = Math.abs(M[i]);
  }
  for (const r of reactions) maxR = Math.max(maxR, Math.abs(r.Ry));

  let totalLoad = 0;
  for (const pl of pointLoads) totalLoad += Math.abs(pl.force);
  for (const u of udls) totalLoad += Math.abs(u.w) * (u.end - u.start);

  document.getElementById('res-rl').textContent = maxR.toFixed(2);
  document.getElementById('res-vs').textContent = maxV.toFixed(2);
  document.getElementById('res-ms').textContent = maxM.toFixed(2);
  document.getElementById('res-tl').textContent = totalLoad.toFixed(2);

  drawAll(totalL, supPos, x, V, M, N);
}

function solveReactions(L, supPos, activeSupports) {
  // Use three-moment equation (force method) for multi-span beams
  // For now, handle simply supported (2 supports) and continuous beams
  
  // Filter vertical reactions only (rollers and pins give vertical; fixed gives vertical+moment)
  const verticalSupports = activeSupports.filter(s => s.type !== 'none');
  
  if (verticalSupports.length < 2) {
    showError('Need at least 2 supports.');
    return null;
  }

  // For a simply supported beam (2 supports), use statics
  if (verticalSupports.length === 2) {
    return solveSimpleBeam(L, verticalSupports[0].x, verticalSupports[1].x);
  }

  // For continuous beams, use the three-moment equation
  return solveContinuousBeam(L, verticalSupports);
}

function solveSimpleBeam(L, x1, x2) {
  const span = x2 - x1;
  // Sum of moments about x2
  let sumM = 0;
  // Point loads
  for (const pl of pointLoads) sumM += pl.force * (x2 - pl.pos);
  // UDL
  for (const u of udls) {
    const s = Math.max(u.start, x1), e = Math.min(u.end, x2);
    if (e > s) {
      const resultant = u.w * (e - s);
      const centroid = (s + e) / 2;
      sumM += resultant * (x2 - centroid);
    }
  }
  const R1 = sumM / span;
  // Sum of vertical forces
  let totalV = R1;
  for (const pl of pointLoads) totalV += pl.force;
  for (const u of udls) {
    const s = Math.max(u.start, 0), e = Math.min(u.end, L);
    if (e > s) totalV += u.w * (e - s);
  }
  const R2 = -totalV + R1;
  // Wait, let's redo: ΣFy = 0
  let sumF = 0;
  for (const pl of pointLoads) sumF += pl.force;
  for (const u of udls) sumF += u.w * (u.end - u.start);
  const R2calc = -sumF - R1;
  return [{x: x1, Ry: R1}, {x: x2, Ry: -sumF - R1}];
}

function solveContinuousBeam(L, supports) {
  // Three-moment equation (Clapeyron's theorem) for continuous beams
  // with roller/pin supports
  const n = supports.length; // number of supports
  // We have n unknowns (Ri) and 2 equations from statics, so (n-2) compatibility equations
  
  // Build the system using three-moment equations
  // For each interior support i: 
  //   M_{i-1}*l_i + 2*M_i*(l_i+l_{i+1}) + M_{i+1}*l_{i+1} = -6*(A_i*a_i/l_i + A_{i+1}*b_{i+1}/l_{i+1})
  // where M are bending moments at supports, l spans, A*a/l are load terms
  
  // Boundary conditions: M at end simple supports = 0
  // This gives us n-2 equations for n-2 interior moments
  
  const nSpans = supports.length - 1;
  const spanLengths = [];
  for (let i = 0; i < nSpans; i++) spanLengths.push(supports[i+1].x - supports[i].x);

  // For each span, compute 6Aa/l and 6Ab/l (load integrals)
  // For point load P at distance 'a' from left of span (b = l - a):
  //   6Aa/l = P * b * (l^2 - b^2) / l
  //   6Ab/l = P * a * (l^2 - a^2) / l
  // For UDL w on full span:
  //   6Aa/l = 6Ab/l = w*l^3/4
  
  function loadTerms(spanIdx) {
    const l = spanLengths[spanIdx];
    const x0 = supports[spanIdx].x;
    let termLeft = 0, termRight = 0;

    for (const pl of pointLoads) {
      const relPos = pl.pos - x0;
      if (relPos > 1e-9 && relPos < l - 1e-9) {
        const a = relPos, b = l - a;
        const P = -pl.force; // convert to downward positive for equation
        termLeft += P * b * (l*l - b*b) / l;
        termRight += P * a * (l*l - a*a) / l;
      }
    }

    for (const u of udls) {
      const start = Math.max(u.start, x0);
      const end = Math.min(u.end, x0 + l);
      if (end <= start) continue;
      // Partial UDL: integrate
      const w = -u.w; // downward positive
      const a1 = start - x0, a2 = end - x0;
      // 6Aa/l = integral from a1 to a2 of w*(l-xi)*(l^2-(l-xi)^2)/l dxi... use numerical
      const ns = 200;
      const dxi = (a2 - a1) / ns;
      for (let j = 0; j < ns; j++) {
        const xi = a1 + (j + 0.5) * dxi;
        const b = l - xi;
        termLeft += w * dxi * b * (l*l - b*b) / l;
        const bi = xi;
        termRight += w * dxi * bi * (l*l - bi*bi) / l;
      }
    }
    return {termLeft, termRight};
  }

  // Setup linear system for interior moments M_1 ... M_{n-2}
  // (M_0 = M_{n-1} = 0 for simple end supports)
  // Check for fixed ends
  const leftFixed = supports[0].type === 'fixed';
  const rightFixed = supports[n-1].type === 'fixed';

  const interior = [];
  for (let i = 0; i < n; i++) interior.push(i); // all supports' moments
  
  // For simple ends: M[0] = 0, M[n-1] = 0
  // For fixed ends: add compatibility at ends too
  // Simple approach: just treat all end supports as pinned/roller (M=0 at ends)
  // This covers most cases
  
  if (nSpans < 2) return solveSimpleBeam(L, supports[0].x, supports[n-1].x);

  const size = nSpans - 1; // number of interior moments
  const A = Array.from({length: size}, () => new Float64Array(size));
  const b = new Float64Array(size);

  for (let k = 0; k < size; k++) {
    const i = k + 1; // interior support index
    const li = spanLengths[i-1];
    const li1 = spanLengths[i];
    const {termRight: tr_left} = loadTerms(i-1);
    const {termLeft: tl_right} = loadTerms(i);

    A[k][k] = 2 * (li + li1);
    if (k > 0) A[k][k-1] = li;
    if (k < size-1) A[k][k+1] = li1;

    b[k] = -(tr_left + tl_right);
    // Adjust for fixed end moments (if needed - skip for now)
  }

  // Solve linear system (Gaussian elimination)
  const M_interior = gaussSolve(A, b, size);
  const M_supports = new Float64Array(n);
  for (let i = 1; i < n-1; i++) M_supports[i] = M_interior[i-1];

  // Compute reactions from moments
  const reactions = [];
  for (let i = 0; i < n; i++) {
    // Contribution from spans on left and right
    let Ri = 0;
    if (i > 0) {
      const l = spanLengths[i-1];
      const x0 = supports[i-1].x;
      // Loads in left span
      for (const pl of pointLoads) {
        const rel = pl.pos - x0;
        if (rel > 1e-9 && rel < l - 1e-9) {
          Ri += pl.force * (l - rel) / l;
        }
      }
      for (const u of udls) {
        const s = Math.max(u.start, x0), e = Math.min(u.end, x0 + l);
        if (e > s) Ri += u.w * (e - s) * (x0 + l - (s+e)/2) / l;
      }
      Ri += (M_supports[i-1] - M_supports[i]) / l;
    }
    if (i < n-1) {
      const l = spanLengths[i];
      const x0 = supports[i].x;
      for (const pl of pointLoads) {
        const rel = pl.pos - x0;
        if (rel > 1e-9 && rel < l - 1e-9) {
          Ri += pl.force * rel / l;
        }
      }
      for (const u of udls) {
        const s = Math.max(u.start, x0), e = Math.min(u.end, x0 + l);
        if (e > s) Ri += u.w * (e - s) * ((s+e)/2 - x0) / l;
      }
      Ri += (M_supports[i+1] - M_supports[i]) / l;
    }
    reactions.push({x: supports[i].x, Ry: Ri});
  }
  return reactions;
}

function gaussSolve(A, b, n) {
  // Forward elimination
  for (let i = 0; i < n; i++) {
    // Pivot
    let maxRow = i;
    for (let k = i+1; k < n; k++) if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
    [A[i], A[maxRow]] = [A[maxRow], A[i]];
    [b[i], b[maxRow]] = [b[maxRow], b[i]];
    
    for (let k = i+1; k < n; k++) {
      const f = A[k][i] / A[i][i];
      for (let j = i; j < n; j++) A[k][j] -= f * A[i][j];
      b[k] -= f * b[i];
    }
  }
  // Back substitution
  const x = new Float64Array(n);
  for (let i = n-1; i >= 0; i--) {
    x[i] = b[i];
    for (let j = i+1; j < n; j++) x[i] -= A[i][j] * x[j];
    x[i] /= A[i][i];
  }
  return x;
}

// ─── Drawing ──────────────────────────────────────────────────────────────────
function resizeCanvas(canvas) {
  const rect = canvas.parentElement.getBoundingClientRect();
  const w = rect.width - 40;
  if (canvas.width !== w) canvas.width = w;
}

function drawAll(L, supPos, x, V, M, N) {
  const canvases = ['beamCanvas','sfdCanvas','bmdCanvas'];
  canvases.forEach(id => {
    const c = document.getElementById(id);
    const r = c.parentElement.getBoundingClientRect();
    c.width = Math.max(400, r.width - 40);
  });

  drawBeam(L, supPos);
  drawSFD(L, x, V, N);
  drawBMD(L, x, M, N);
}

function mapX(xi, L, pad, W) { return pad + (xi / L) * (W - 2 * pad); }

function drawBeam(L, supPos) {
  const canvas = document.getElementById('beamCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  const pad = 50, beamY = H * 0.55, bh = 12;
  const mapx = xi => mapX(xi, L, pad, W);

  // Beam
  ctx.fillStyle = '#4f9fff';
  ctx.fillRect(mapx(0), beamY - bh/2, mapx(L) - mapx(0), bh);

  // Supports
  supPos.forEach((sx, i) => {
    const type = supportTypes[i] || 'roller';
    const px = mapx(sx);
    ctx.fillStyle = '#ffd080';
    ctx.strokeStyle = '#ffd080';
    ctx.lineWidth = 2;
    if (type === 'pin' || type === 'roller') {
      ctx.beginPath();
      ctx.moveTo(px, beamY + bh/2);
      ctx.lineTo(px - 12, beamY + bh/2 + 20);
      ctx.lineTo(px + 12, beamY + bh/2 + 20);
      ctx.closePath();
      ctx.fillStyle = '#ffd080';
      ctx.fill();
      if (type === 'roller') {
        ctx.beginPath();
        ctx.arc(px, beamY + bh/2 + 24, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#ffd080'; ctx.fill();
      }
    } else if (type === 'fixed') {
      ctx.fillStyle = '#ff8040';
      ctx.fillRect(px - 4, beamY - bh/2 - 10, 8, bh + 30);
    }
    // Label reaction
    ctx.fillStyle = '#ffd080';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`R${i+1}`, px, beamY + bh/2 + 40);
  });

  // UDLs
  for (const u of udls) {
    const x1 = mapx(Math.max(u.start,0)), x2 = mapx(Math.min(u.end,L));
    ctx.fillStyle = 'rgba(180,100,255,0.18)';
    ctx.fillRect(x1, beamY - bh/2 - 40, x2-x1, 40);
    ctx.strokeStyle = '#cc70ff';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x1, beamY - bh/2 - 40); ctx.lineTo(x2, beamY - bh/2 - 40); ctx.stroke();
    // Arrows
    for (let ax = x1 + 8; ax < x2; ax += 18) {
      arrow(ctx, ax, beamY - bh/2 - 36, ax, beamY - bh/2, '#cc70ff');
    }
    ctx.fillStyle = '#cc70ff';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`${Math.abs(u.w)}kN/m`, (x1+x2)/2, beamY - bh/2 - 44);
  }

  // Point loads
  for (const pl of pointLoads) {
    const px = mapx(pl.pos);
    const down = pl.force < 0;
    const ay = down ? beamY - bh/2 - 40 : beamY - bh/2;
    const by = down ? beamY - bh/2 : beamY - bh/2 - 40;
    arrow(ctx, px, ay, px, by, '#f0c040', 2.5);
    ctx.fillStyle = '#f0c040';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`${Math.abs(pl.force)}kN`, px, down ? beamY - bh/2 - 44 : beamY - bh/2 - 44);
  }

  // Span labels
  let cumX = 0;
  ctx.fillStyle = '#555';
  ctx.font = '10px sans-serif';
  for (let i = 0; i < spans.length; i++) {
    const mx = mapx(cumX + spans[i]/2);
    ctx.textAlign = 'center';
    ctx.fillText(`${spans[i]}m`, mx, H - 5);
    cumX += spans[i];
  }
}

function arrow(ctx, x1, y1, x2, y2, color, lw=1.5) {
  ctx.strokeStyle = color; ctx.lineWidth = lw;
  ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
  const angle = Math.atan2(y2 - y1, x2 - x1);
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - 7 * Math.cos(angle - 0.4), y2 - 7 * Math.sin(angle - 0.4));
  ctx.lineTo(x2 - 7 * Math.cos(angle + 0.4), y2 - 7 * Math.sin(angle + 0.4));
  ctx.closePath(); ctx.fill();
}

function drawDiagram(canvasId, L, x, Y, N, color, label, positiveUp) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  const pad = 50, chartH = H - 40;
  const axisY = positiveUp ? chartH * 0.65 : chartH * 0.45;
  const mapx = xi => mapX(xi / L * L, L, pad, W);

  // Find range
  let yMin = 0, yMax = 0;
  for (let i = 0; i <= N; i++) { yMin = Math.min(yMin, Y[i]); yMax = Math.max(yMax, Y[i]); }
  const range = Math.max(Math.abs(yMin), Math.abs(yMax)) || 1;

  const scaleY = (axisY - 10) / range;
  const py = val => axisY - val * scaleY;

  // Fill
  ctx.beginPath();
  ctx.moveTo(mapx(x[0]), axisY);
  for (let i = 0; i <= N; i++) ctx.lineTo(mapx(x[i]), py(Y[i]));
  ctx.lineTo(mapx(x[N]), axisY);
  ctx.closePath();
  ctx.fillStyle = hexToRgba(color, 0.2);
  ctx.fill();

  // Line
  ctx.beginPath();
  ctx.moveTo(mapx(x[0]), py(Y[0]));
  for (let i = 1; i <= N; i++) ctx.lineTo(mapx(x[i]), py(Y[i]));
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.stroke();

  // Axis
  ctx.strokeStyle = '#444'; ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(pad - 10, axisY);
  ctx.lineTo(W - pad + 10, axisY);
  ctx.stroke();

  // Grid lines
  ctx.strokeStyle = '#222'; ctx.lineWidth = 0.5;
  const steps = 4;
  for (let s = 1; s <= steps; s++) {
    const yv = range * s / steps;
    [py(yv), py(-yv)].forEach(y => {
      ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(W-pad, y); ctx.stroke();
    });
  }

  // Y labels
  ctx.fillStyle = '#666'; ctx.font = '10px monospace'; ctx.textAlign = 'right';
  for (let s = 0; s <= steps; s++) {
    const yv = range * s / steps;
    if (s > 0) {
      ctx.fillText(yv.toFixed(1), pad - 4, py(yv) + 3);
      ctx.fillText((-yv).toFixed(1), pad - 4, py(-yv) + 3);
    } else {
      ctx.fillText('0', pad - 4, axisY + 3);
    }
  }

  // X labels
  ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.font = '10px monospace';
  const xSteps = Math.min(10, Math.ceil(L));
  for (let s = 0; s <= xSteps; s++) {
    const xv = L * s / xSteps;
    ctx.fillText(xv.toFixed(1), mapx(xv), chartH + 15);
  }

  // Axis label
  ctx.fillStyle = color; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'left';
  ctx.fillText(label, pad, 14);
  ctx.fillStyle = '#555'; ctx.textAlign = 'right'; ctx.font = '10px sans-serif';
  ctx.fillText('x (m) →', W - pad, chartH + 15);

  // Max/min annotations
  let maxI = 0, minI = 0;
  for (let i = 1; i <= N; i++) {
    if (Y[i] > Y[maxI]) maxI = i;
    if (Y[i] < Y[minI]) minI = i;
  }
  if (Math.abs(Y[maxI]) > 0.01) annotate(ctx, mapx(x[maxI]), py(Y[maxI]), Y[maxI], color);
  if (Math.abs(Y[minI]) > 0.01 && minI !== maxI) annotate(ctx, mapx(x[minI]), py(Y[minI]), Y[minI], '#ff6b6b');
}

function annotate(ctx, px, py, val, color) {
  ctx.fillStyle = color;
  ctx.font = 'bold 10px monospace';
  ctx.textAlign = 'center';
  ctx.fillText(val.toFixed(2), px, py - 4);
  ctx.beginPath();
  ctx.arc(px, py, 3, 0, Math.PI * 2);
  ctx.fillStyle = color; ctx.fill();
}

function drawSFD(L, x, V, N) {
  drawDiagram('sfdCanvas', L, x, V, N, '#ff6b3d', 'Shear Force (kN)', true);
}
function drawBMD(L, x, M, N) {
  drawDiagram('bmdCanvas', L, x, M, N, '#2ecc71', 'Bending Moment (kN·m)', false);
}

function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${alpha})`;
}

function showError(msg) {
  document.getElementById('error-box').innerHTML = `<div class="error">⚠ ${msg}</div>`;
}

function resetAll() {
  spans = [4, 4];
  supportTypes = [];
  pointLoads = [];
  udls = [];
  renderSpans();
  renderLists();
  ['beamCanvas','sfdCanvas','bmdCanvas'].forEach(id => {
    const c = document.getElementById(id);
    const ctx = c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
  });
  ['res-rl','res-vs','res-ms','res-tl'].forEach(id => document.getElementById(id).textContent = '—');
}

// Resize on window resize
window.addEventListener('resize', () => { try { analyze(); } catch(e){} });

// Boot
init();
</script>
</body>
</html>
