<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TRUSS — Structural Modeler</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0c0f;
    --panel: #111418;
    --border: #1e2530;
    --accent: #00e5ff;
    --accent2: #ff6b35;
    --tension: #ff4444;
    --compression: #44aaff;
    --neutral: #888;
    --text: #c8d8e8;
    --text-dim: #556677;
    --node-r: 9;
  }

  * { margin:0; padding:0; box-sizing:border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Rajdhani', sans-serif;
    font-weight: 400;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  header {
    display: flex;
    align-items: center;
    gap: 24px;
    padding: 10px 20px;
    border-bottom: 1px solid var(--border);
    background: var(--panel);
    flex-shrink: 0;
  }

  .logo {
    font-family: 'Share Tech Mono', monospace;
    font-size: 22px;
    color: var(--accent);
    letter-spacing: 6px;
  }

  .logo span { color: var(--accent2); }

  .tagline {
    font-size: 11px;
    color: var(--text-dim);
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  .toolbar {
    display: flex;
    gap: 6px;
    margin-left: auto;
    align-items: center;
  }

  .tool-btn {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 6px 14px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 13px;
    font-weight: 600;
    letter-spacing: 1px;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.15s;
  }

  .tool-btn:hover { border-color: var(--accent); color: var(--accent); }
  .tool-btn.active { background: var(--accent); color: var(--bg); border-color: var(--accent); }

  .tool-btn.danger:hover { border-color: var(--tension); color: var(--tension); }

  .main {
    display: flex;
    flex: 1;
    overflow: hidden;
  }

  #canvas {
    flex: 1;
    cursor: crosshair;
    display: block;
    background: var(--bg);
  }

  .sidebar {
    width: 260px;
    background: var(--panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    flex-shrink: 0;
  }

  .panel {
    border-bottom: 1px solid var(--border);
    padding: 14px 16px;
  }

  .panel-title {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: var(--accent);
    letter-spacing: 3px;
    text-transform: uppercase;
    margin-bottom: 12px;
  }

  .stat-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-size: 13px;
  }

  .stat-label { color: var(--text-dim); }
  .stat-val {
    font-family: 'Share Tech Mono', monospace;
    color: var(--text);
    font-size: 12px;
  }

  .mode-group {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
    margin-bottom: 10px;
  }

  .mode-btn {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 8px 6px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    text-align: center;
    letter-spacing: 1px;
    text-transform: uppercase;
    transition: all 0.15s;
  }

  .mode-btn:hover { border-color: var(--accent); color: var(--accent); }
  .mode-btn.active { background: rgba(0,229,255,0.12); border-color: var(--accent); color: var(--accent); }

  .props { display: flex; flex-direction: column; gap: 8px; }

  .prop-row { display: flex; flex-direction: column; gap: 3px; }

  .prop-label {
    font-size: 11px;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .prop-row select, .prop-row input {
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 5px 8px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px;
    outline: none;
    width: 100%;
  }

  .prop-row select:focus, .prop-row input:focus {
    border-color: var(--accent);
  }

  .member-list {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .member-item {
    background: var(--bg);
    border: 1px solid var(--border);
    padding: 6px 10px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .force-bar {
    height: 3px;
    margin-top: 3px;
    border-radius: 2px;
    transition: width 0.3s;
  }

  .legend {
    display: flex;
    gap: 16px;
    font-size: 11px;
    margin-top: 8px;
  }

  .legend-item { display: flex; align-items: center; gap: 6px; }
  .legend-dot { width: 12px; height: 3px; border-radius: 2px; }

  .status-bar {
    padding: 5px 16px;
    border-top: 1px solid var(--border);
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    color: var(--text-dim);
    background: var(--panel);
    flex-shrink: 0;
  }

  .instructions {
    font-size: 12px;
    color: var(--text-dim);
    line-height: 1.7;
    padding: 4px 0;
  }

  .instructions b { color: var(--accent2); font-weight: 600; }

  .action-btn {
    width: 100%;
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 8px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 13px;
    font-weight: 700;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    transition: all 0.15s;
    margin-top: 6px;
  }

  .action-btn:hover { border-color: var(--accent2); color: var(--accent2); }
  .action-btn.primary:hover { border-color: var(--accent); color: var(--accent); }

  .grid-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: var(--text-dim);
    cursor: pointer;
    user-select: none;
  }

  .grid-toggle input { accent-color: var(--accent); cursor: pointer; }
</style>
</head>
<body>

<header>
  <div>
    <div class="logo">TR<span>U</span>SS</div>
    <div class="tagline">2D Structural Modeler</div>
  </div>
  <div class="toolbar">
    <button class="tool-btn" onclick="loadPreset('pratt')">Pratt</button>
    <button class="tool-btn" onclick="loadPreset('howe')">Howe</button>
    <button class="tool-btn" onclick="loadPreset('warren')">Warren</button>
    <button class="tool-btn" onclick="loadPreset('fink')">Fink</button>
    <button class="tool-btn danger" onclick="clearAll()">Clear</button>
  </div>
</header>

<div class="main">
  <canvas id="canvas"></canvas>

  <div class="sidebar">

    <div class="panel">
      <div class="panel-title">Mode</div>
      <div class="mode-group">
        <button class="mode-btn active" id="btn-node" onclick="setMode('node')">Node</button>
        <button class="mode-btn" id="btn-member" onclick="setMode('member')">Member</button>
        <button class="mode-btn" id="btn-support" onclick="setMode('support')">Support</button>
        <button class="mode-btn" id="btn-load" onclick="setMode('load')">Load</button>
        <button class="mode-btn" id="btn-select" onclick="setMode('select')">Select</button>
        <button class="mode-btn" id="btn-delete" onclick="setMode('delete')">Delete</button>
      </div>
      <div class="instructions" id="instructions">
        <b>Click</b> on canvas to place nodes
      </div>
    </div>

    <div class="panel">
      <div class="panel-title">Properties</div>
      <div class="props">
        <div class="prop-row">
          <div class="prop-label">Load (kN)</div>
          <input type="number" id="load-val" value="10" step="1">
        </div>
        <div class="prop-row">
          <div class="prop-label">Load Angle (°)</div>
          <input type="number" id="load-angle" value="270" step="15">
        </div>
        <div class="prop-row">
          <div class="prop-label">E (GPa)</div>
          <input type="number" id="e-val" value="200" step="10">
        </div>
        <div class="prop-row">
          <div class="prop-label">Area (cm²)</div>
          <input type="number" id="a-val" value="10" step="1">
        </div>
        <label class="grid-toggle" style="margin-top:6px">
          <input type="checkbox" id="snap-grid" checked> Snap to Grid (50px)
        </label>
      </div>
    </div>

    <div class="panel">
      <div class="panel-title">Analysis</div>
      <div class="stat-row"><span class="stat-label">Nodes</span><span class="stat-val" id="stat-nodes">0</span></div>
      <div class="stat-row"><span class="stat-label">Members</span><span class="stat-val" id="stat-members">0</span></div>
      <div class="stat-row"><span class="stat-label">Reactions</span><span class="stat-val" id="stat-dof">—</span></div>
      <div class="stat-row"><span class="stat-label">Stability</span><span class="stat-val" id="stat-stable">—</span></div>
      <button class="action-btn primary" onclick="analyze()">▶ Analyze</button>
    </div>

    <div class="panel" style="flex:1">
      <div class="panel-title">Member Forces</div>
      <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:var(--tension)"></div><span>Tension</span></div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--compression)"></div><span>Comp.</span></div>
      </div>
      <div class="member-list" id="member-list" style="margin-top:10px"></div>
    </div>

  </div>
</div>

<div class="status-bar" id="status-bar">Ready — select a mode and begin modeling</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let nodes = [];
let members = [];
let mode = 'node';
let selectedNode = null;
let memberStart = null;
let hoveredNode = null;
let analysisResult = null;
let mousePos = {x:0, y:0};
let selectedItem = null;

const GRID = 50;
const SNAP = true;

function resize() {
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
  draw();
}

window.addEventListener('resize', resize);
resize();

function setMode(m) {
  mode = m;
  selectedNode = null;
  memberStart = null;
  selectedItem = null;
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('btn-'+m).classList.add('active');

  const instMap = {
    node: '<b>Click</b> on canvas to place nodes',
    member: '<b>Click</b> a node to start, then <b>click</b> another to connect',
    support: '<b>Click</b> a node to cycle its support (Pin → Roller → Fixed → None)',
    load: '<b>Click</b> a node to apply a point load',
    select: '<b>Click</b> a node or member to inspect/move',
    delete: '<b>Click</b> a node or member to delete it',
  };
  document.getElementById('instructions').innerHTML = instMap[m] || '';
  canvas.style.cursor = m === 'select' ? 'default' : 'crosshair';
  draw();
}

function snap(v) {
  if (document.getElementById('snap-grid').checked) return Math.round(v/GRID)*GRID;
  return Math.round(v);
}

function getNodeAt(x,y,r=18) {
  for(let n of nodes) {
    if(Math.hypot(n.x-x, n.y-y) < r) return n;
  }
  return null;
}

function getMemberNear(x,y,thresh=8) {
  for(let m of members) {
    let a = nodes[m.a], b = nodes[m.b];
    let dx=b.x-a.x, dy=b.y-a.y;
    let len=Math.hypot(dx,dy);
    if(len===0) continue;
    let t=((x-a.x)*dx+(y-a.y)*dy)/(len*len);
    t=Math.max(0,Math.min(1,t));
    let px=a.x+t*dx, py=a.y+t*dy;
    if(Math.hypot(x-px,y-py)<thresh) return m;
  }
  return null;
}

canvas.addEventListener('mousemove', e => {
  let r = canvas.getBoundingClientRect();
  mousePos.x = e.clientX - r.left;
  mousePos.y = e.clientY - r.top;
  hoveredNode = getNodeAt(mousePos.x, mousePos.y);
  setStatus(`x: ${snap(mousePos.x)}  y: ${snap(mousePos.y)}`);
  draw();
});

canvas.addEventListener('click', e => {
  let r = canvas.getBoundingClientRect();
  let x = e.clientX - r.left;
  let y = e.clientY - r.top;

  if(mode==='node') {
    let sx=snap(x), sy=snap(y);
    if(!getNodeAt(sx,sy,12)) {
      nodes.push({x:sx, y:sy, support:'none', loads:[]});
      analysisResult=null;
    }
  } else if(mode==='member') {
    let n = getNodeAt(x,y);
    if(n) {
      if(!memberStart) { memberStart=n; }
      else if(memberStart!==n) {
        let ai=nodes.indexOf(memberStart), bi=nodes.indexOf(n);
        if(!members.find(m=>(m.a===ai&&m.b===bi)||(m.a===bi&&m.b===ai))) {
          members.push({a:ai,b:bi,force:null});
          analysisResult=null;
        }
        memberStart=null;
      }
    }
  } else if(mode==='support') {
    let n = getNodeAt(x,y);
    if(n) {
      const cycle = {none:'pin',pin:'roller',roller:'fixed',fixed:'none'};
      n.support = cycle[n.support];
      analysisResult=null;
    }
  } else if(mode==='load') {
    let n = getNodeAt(x,y);
    if(n) {
      let mag = parseFloat(document.getElementById('load-val').value)||10;
      let ang = parseFloat(document.getElementById('load-angle').value)||270;
      n.loads.push({mag, ang});
      analysisResult=null;
    }
  } else if(mode==='delete') {
    let n = getNodeAt(x,y);
    if(n) {
      let ni = nodes.indexOf(n);
      members = members.filter(m=>m.a!==ni&&m.b!==ni);
      members.forEach(m=>{
        if(m.a>ni)m.a--;
        if(m.b>ni)m.b--;
      });
      nodes.splice(ni,1);
      analysisResult=null;
    } else {
      let m = getMemberNear(x,y);
      if(m) {
        members.splice(members.indexOf(m),1);
        analysisResult=null;
      }
    }
  }

  updateStats();
  draw();
});

function drawGrid() {
  ctx.strokeStyle = 'rgba(30,37,48,0.8)';
  ctx.lineWidth = 1;
  for(let x=0;x<canvas.width;x+=GRID) {
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
  }
  for(let y=0;y<canvas.height;y+=GRID) {
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
  }
  // dots at intersections
  ctx.fillStyle = 'rgba(50,65,85,0.5)';
  for(let x=0;x<canvas.width;x+=GRID)
    for(let y=0;y<canvas.height;y+=GRID) {
      ctx.beginPath(); ctx.arc(x,y,1.5,0,Math.PI*2); ctx.fill();
    }
}

function drawMember(m) {
  let a=nodes[m.a], b=nodes[m.b];
  if(!a||!b) return;

  let hasResult = m.force !== null && m.force !== undefined;
  let col = '#334455';
  let lw = 2;

  if(hasResult) {
    if(m.force > 0.001) { col='#ff4444'; lw=2+Math.min(6,Math.abs(m.force)/10); }
    else if(m.force < -0.001) { col='#44aaff'; lw=2+Math.min(6,Math.abs(m.force)/10); }
    else { col='#888'; lw=2; }
  }

  if(m===hoveredMember) { col='rgba(0,229,255,0.8)'; lw=Math.max(lw,3); }

  ctx.strokeStyle=col;
  ctx.lineWidth=lw;
  ctx.beginPath();
  ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
  ctx.stroke();

  // label
  if(hasResult) {
    let mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    ctx.fillStyle='rgba(10,12,15,0.7)';
    ctx.font='bold 10px Share Tech Mono,monospace';
    let txt=(m.force>0?'+':'')+m.force.toFixed(1)+'kN';
    let tw=ctx.measureText(txt).width;
    ctx.fillRect(mx-tw/2-3,my-8,tw+6,14);
    ctx.fillStyle=m.force>0.001?'#ff7777':m.force<-0.001?'#77aaff':'#aaa';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(txt,mx,my);
  }
}

let hoveredMember = null;

canvas.addEventListener('mousemove', e => {
  let r=canvas.getBoundingClientRect();
  let x=e.clientX-r.left, y=e.clientY-r.top;
  hoveredMember = (mode==='delete'||mode==='select') ? getMemberNear(x,y) : null;
});

function drawNode(n, i) {
  let hov = n===hoveredNode;
  let col = '#00e5ff';

  if(n.support==='pin') col='#ffd700';
  else if(n.support==='roller') col='#ff9944';
  else if(n.support==='fixed') col='#ff44aa';

  // glow
  if(hov || n===memberStart) {
    ctx.shadowBlur=18; ctx.shadowColor=col;
  }

  ctx.beginPath();
  ctx.arc(n.x, n.y, 8, 0, Math.PI*2);
  ctx.fillStyle = n===memberStart ? '#fff' : col;
  ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.15)';
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.shadowBlur=0;

  // node index
  ctx.fillStyle='var(--bg)';
  ctx.font='bold 9px Share Tech Mono,monospace';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(i, n.x, n.y);

  // support symbol
  if(n.support==='pin') drawPin(n.x, n.y, '#ffd700');
  else if(n.support==='roller') drawRoller(n.x, n.y, '#ff9944');
  else if(n.support==='fixed') drawFixed(n.x, n.y, '#ff44aa');

  // loads
  for(let l of n.loads) {
    let ang=(l.ang-90)*Math.PI/180;
    let scale=20+l.mag*1.5;
    let ex=n.x+Math.cos(ang)*scale, ey=n.y+Math.sin(ang)*scale;
    ctx.strokeStyle='#ff6b35';
    ctx.lineWidth=2;
    ctx.beginPath();
    // arrow line
    let ox=n.x+Math.cos(ang)*11, oy=n.y+Math.sin(ang)*11;
    ctx.moveTo(ex,ey); ctx.lineTo(ox,oy);
    ctx.stroke();
    // arrowhead
    let hx=ox-Math.cos(ang)*10, hy=oy-Math.sin(ang)*10;
    let px=-Math.sin(ang)*5, py=Math.cos(ang)*5;
    ctx.fillStyle='#ff6b35';
    ctx.beginPath();
    ctx.moveTo(ox,oy);
    ctx.lineTo(hx+px,hy+py);
    ctx.lineTo(hx-px,hy-py);
    ctx.closePath(); ctx.fill();
    // label
    ctx.fillStyle='#ff6b35';
    ctx.font='bold 9px Rajdhani,sans-serif';
    ctx.textAlign='center';
    ctx.fillText(l.mag+'kN', ex+Math.cos(ang)*14, ey+Math.sin(ang)*14);
  }
}

function drawPin(x,y,col) {
  ctx.fillStyle=col+'44';
  ctx.strokeStyle=col;
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(x-12,y+14); ctx.lineTo(x,y+9); ctx.lineTo(x+12,y+14);
  ctx.closePath(); ctx.fill(); ctx.stroke();
  ctx.beginPath();
  for(let i=-2;i<=2;i++) { ctx.moveTo(x-14+i*4,y+16); ctx.lineTo(x-18+i*4,y+20); }
  ctx.stroke();
}

function drawRoller(x,y,col) {
  ctx.strokeStyle=col;
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(x-12,y+14); ctx.lineTo(x,y+9); ctx.lineTo(x+12,y+14);
  ctx.stroke();
  ctx.beginPath();
  ctx.ellipse(x-5,y+17,3,3,0,0,Math.PI*2);
  ctx.ellipse(x+5,y+17,3,3,0,0,Math.PI*2);
  ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x-14,y+21); ctx.lineTo(x+14,y+21); ctx.stroke();
}

function drawFixed(x,y,col) {
  ctx.strokeStyle=col;
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(x-1,y+9); ctx.lineTo(x-1,y+20);
  ctx.stroke();
  ctx.lineWidth=3; ctx.strokeStyle=col+'88';
  ctx.beginPath(); ctx.moveTo(x-1,y+9); ctx.lineTo(x-1,y+20); ctx.stroke();
  ctx.lineWidth=1.5; ctx.strokeStyle=col;
  for(let i=0;i<4;i++) {
    ctx.beginPath();
    ctx.moveTo(x-1, y+10+i*3);
    ctx.lineTo(x-8, y+14+i*3);
    ctx.stroke();
  }
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();

  // draw members
  for(let m of members) drawMember(m);

  // member-in-progress
  if(mode==='member' && memberStart) {
    let tx=snap(mousePos.x), ty=snap(mousePos.y);
    let hn = getNodeAt(mousePos.x,mousePos.y);
    ctx.setLineDash([6,4]);
    ctx.strokeStyle = hn&&hn!==memberStart ? '#00e5ff' : 'rgba(0,229,255,0.3)';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(memberStart.x,memberStart.y);
    ctx.lineTo(hn?hn.x:tx, hn?hn.y:ty);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // draw nodes
  for(let i=0;i<nodes.length;i++) drawNode(nodes[i],i);

  // snap preview
  if(mode==='node') {
    let sx=snap(mousePos.x), sy=snap(mousePos.y);
    if(!getNodeAt(sx,sy,12)) {
      ctx.strokeStyle='rgba(0,229,255,0.3)';
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.arc(sx,sy,8,0,Math.PI*2); ctx.stroke();
    }
  }
}

function updateStats() {
  document.getElementById('stat-nodes').textContent = nodes.length;
  document.getElementById('stat-members').textContent = members.length;
  let supports = nodes.filter(n=>n.support!=='none');
  let dof = supports.reduce((s,n)=>s+(n.support==='pin'?2:n.support==='roller'?1:n.support==='fixed'?3:0),0);
  document.getElementById('stat-dof').textContent = dof;
  // m+r >= 2n => stable (simple check)
  let stable = members.length+dof >= 2*nodes.length;
  let det = (members.length+dof) - 2*nodes.length;
  document.getElementById('stat-stable').textContent =
    nodes.length===0 ? '—' :
    det<0 ? '⚠ Under' :
    det===0 ? '✓ Det.' :
    '⚠ Over('+det+')';
}

function setStatus(s) {
  document.getElementById('status-bar').textContent = s;
}

// ===== ANALYSIS (Method of Joints - Direct Stiffness) =====
function analyze() {
  if(nodes.length<2||members.length<1) return;

  let n=nodes.length, m=members.length;
  let dofs=2*n;
  let K=Array.from({length:dofs},()=>new Array(dofs).fill(0));
  let F=new Array(dofs).fill(0);
  let E=parseFloat(document.getElementById('e-val').value)*1e6; // kN/m²
  let A=parseFloat(document.getElementById('a-val').value)*1e-4; // m²
  const PX=60; // pixel to meter (50px = 1m)

  for(let mem of members) {
    let ni=mem.a,nj=mem.b;
    let xi=nodes[ni].x/PX, yi=-nodes[ni].y/PX;
    let xj=nodes[nj].x/PX, yj=-nodes[nj].y/PX;
    let dx=xj-xi, dy=yj-yi;
    let L=Math.hypot(dx,dy);
    let c=dx/L, s=dy/L;
    let k=E*A/L;
    let [i0,i1,j0,j1]=[2*ni,2*ni+1,2*nj,2*nj+1];
    let ke=[c*c,c*s,-c*c,-c*s,
            c*s,s*s,-c*s,-s*s,
            -c*c,-c*s,c*c,c*s,
            -c*s,-s*s,c*s,s*s];
    let idxs=[i0,i1,j0,j1];
    for(let a=0;a<4;a++) for(let b=0;b<4;b++) K[idxs[a]][idxs[b]]+=k*ke[a*4+b];
  }

  // apply loads
  for(let ni=0;ni<nodes.length;ni++) {
    for(let l of nodes[ni].loads) {
      let rad=(l.ang-90)*Math.PI/180; // 270deg = downward
      // In screen coords Y is flipped; convert to structural
      let fx=l.mag*Math.cos((l.ang)*Math.PI/180);
      let fy=l.mag*Math.sin((l.ang)*Math.PI/180); // positive = up in structural
      // screen angle: 0=right, 90=down; structural: 0=right, 90=up
      // user input 270 = downward screen = -Y structural
      let angStr=(l.ang)*Math.PI/180;
      F[2*ni]+=l.mag*Math.cos(angStr);
      F[2*ni+1]+=-l.mag*Math.sin(angStr); // flip Y
    }
  }

  // boundary conditions
  let fixed=[];
  for(let ni=0;ni<nodes.length;ni++) {
    let s=nodes[ni].support;
    if(s==='pin'||s==='fixed') { fixed.push(2*ni); fixed.push(2*ni+1); }
    else if(s==='roller') { fixed.push(2*ni+1); } // fix vertical
    // fixed support: fix both + rotation (we ignore rotation for truss)
  }

  // reduce system
  let free=[];
  for(let i=0;i<dofs;i++) if(!fixed.includes(i)) free.push(i);

  if(free.length===0) { setStatus('All DOFs constrained'); return; }

  let Kff=free.map(r=>free.map(c=>K[r][c]));
  let Ff=free.map(r=>F[r]);

  let U=solveLinear(Kff,Ff);
  if(!U) { setStatus('Singular matrix — structure may be unstable'); return; }

  let Ufull=new Array(dofs).fill(0);
  free.forEach((gi,li)=>Ufull[gi]=U[li]);

  // compute member forces
  for(let mem of members) {
    let ni=mem.a, nj=mem.b;
    let xi=nodes[ni].x/PX, yi=-nodes[ni].y/PX;
    let xj=nodes[nj].x/PX, yj=-nodes[nj].y/PX;
    let dx=xj-xi, dy=yj-yi;
    let L=Math.hypot(dx,dy);
    let c=dx/L, s=dy/L;
    let k=E*A/L;
    let ui=Ufull[2*ni], vi=Ufull[2*ni+1];
    let uj=Ufull[2*nj], vj=Ufull[2*nj+1];
    mem.force=k*(c*(uj-ui)+s*(vj-vi)); // positive = tension
  }

  analysisResult=true;
  updateMemberList();
  draw();
  setStatus('Analysis complete ✓');
}

function solveLinear(A,b) {
  let n=A.length;
  let M=A.map((r,i)=>[...r,b[i]]);
  for(let col=0;col<n;col++) {
    let max=col;
    for(let row=col+1;row<n;row++) if(Math.abs(M[row][col])>Math.abs(M[max][col])) max=row;
    [M[col],M[max]]=[M[max],M[col]];
    if(Math.abs(M[col][col])<1e-12) return null;
    let piv=M[col][col];
    for(let j=col;j<=n;j++) M[col][j]/=piv;
    for(let row=0;row<n;row++) {
      if(row===col) continue;
      let f=M[row][col];
      for(let j=col;j<=n;j++) M[row][j]-=f*M[col][j];
    }
  }
  return M.map(r=>r[n]);
}

function updateMemberList() {
  let list=document.getElementById('member-list');
  list.innerHTML='';
  let maxF=Math.max(...members.map(m=>Math.abs(m.force||0)),0.001);
  members.forEach((m,i)=>{
    let col = m.force>0.001?'var(--tension)':m.force<-0.001?'var(--compression)':'var(--neutral)';
    let typ = m.force>0.001?'T':m.force<-0.001?'C':'—';
    let pct=Math.abs(m.force||0)/maxF*100;
    let div=document.createElement('div');
    div.className='member-item';
    div.style.flexDirection='column';
    div.innerHTML=`
      <div style="display:flex;justify-content:space-between;width:100%">
        <span style="color:#556677">M${i} [${m.a}→${m.b}]</span>
        <span style="color:${col};font-size:11px">${m.force!==null?(m.force.toFixed(2)+' kN '+typ):'—'}</span>
      </div>
      ${m.force!==null?`<div class="force-bar" style="background:${col};width:${pct}%;margin-top:4px"></div>`:''}
    `;
    list.appendChild(div);
  });
}

// ===== PRESETS =====
function clearAll() {
  nodes=[]; members=[]; analysisResult=null;
  document.getElementById('member-list').innerHTML='';
  updateStats(); draw();
}

function loadPreset(type) {
  clearAll();
  let cx=canvas.width/2, cy=canvas.height/2;
  let ox=cx-150, oy=cy-50;
  let s=50; // panel unit

  if(type==='warren') {
    // Warren truss 6 panels
    let pts=[[0,0],[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],
              [0.5,-1],[1.5,-1],[2.5,-1],[3.5,-1],[4.5,-1],[5.5,-1]];
    pts.forEach(([x,y])=>nodes.push({x:ox+x*s,y:oy+y*s,support:'none',loads:[]}));
    let mems=[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[0,7],[7,1],[1,8],[8,2],[2,9],[9,3],[3,10],[10,4],[4,11],[11,5],[5,12],[12,6],[7,8],[8,9],[9,10],[10,11],[11,12]];
    mems.forEach(([a,b])=>members.push({a,b,force:null}));
    nodes[0].support='pin'; nodes[6].support='roller';
    nodes[2].loads=[{mag:20,ang:270}]; nodes[3].loads=[{mag:30,ang:270}]; nodes[4].loads=[{mag:20,ang:270}];
  } else if(type==='pratt') {
    let pts=[[0,0],[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],
              [0,-1],[1,-1],[2,-1],[3,-1],[4,-1],[5,-1],[6,-1]];
    pts.forEach(([x,y])=>nodes.push({x:ox+x*s,y:oy+y*s,support:'none',loads:[]}));
    // bottom chord
    let mems=[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]];
    // top chord
    mems=mems.concat([[7,8],[8,9],[9,10],[10,11],[11,12],[12,13]]);
    // verticals
    mems=mems.concat([[0,7],[1,8],[2,9],[3,10],[4,11],[5,12],[6,13]]);
    // diagonals (Pratt: tension diagonals lean toward center)
    mems=mems.concat([[8,1],[9,2],[10,3],[10,4],[11,5],[12,5]]);
    mems.forEach(([a,b])=>members.push({a,b,force:null}));
    nodes[0].support='pin'; nodes[6].support='roller';
    [2,3,4].forEach(i=>nodes[i].loads=[{mag:15,ang:270}]);
  } else if(type==='howe') {
    let pts=[[0,0],[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],
              [0,-1],[1,-1],[2,-1],[3,-1],[4,-1],[5,-1],[6,-1]];
    pts.forEach(([x,y])=>nodes.push({x:ox+x*s,y:oy+y*s,support:'none',loads:[]}));
    let mems=[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]];
    mems=mems.concat([[7,8],[8,9],[9,10],[10,11],[11,12],[12,13]]);
    mems=mems.concat([[0,7],[1,8],[2,9],[3,10],[4,11],[5,12],[6,13]]);
    // Howe diagonals lean outward
    mems=mems.concat([[7,1],[8,2],[9,3],[10,4],[11,5],[12,6]]);
    // wait, correct: Howe has diagonals in compression pointing outward from center
    mems.forEach(([a,b])=>members.push({a,b,force:null}));
    nodes[0].support='pin'; nodes[6].support='roller';
    [2,3,4].forEach(i=>nodes[i].loads=[{mag:15,ang:270}]);
  } else if(type==='fink') {
    // Fink (roof) truss - triangular shape
    let W=6*s, H=2*s;
    let base=[[0,0],[1,0],[2,0],[3,0],[4,0],[5,0],[6,0]];
    let top=[[0,-H],[1,-H*0.67],[2,-H*0.33],[3,0],[3,-H],[1.5,-H*0.83],[4.5,-H*0.33]];
    // Simple symmetric truss
    let pts=[];
    // bottom: 0-6, peak: 7, quarter pts: 8,9
    pts=[[0,0],[2,0],[4,0],[6,0],[1,-1],[2,-2],[3,-1],[4,-1],[5,-1]];
    pts.forEach(([x,y])=>nodes.push({x:ox+x*s,y:oy+y*s,support:'none',loads:[]}));
    let mems=[[0,1],[1,2],[2,3],[0,5],[5,4],[4,1],[1,6],[6,2],[2,7],[7,3],[5,6],[6,7],[4,5],[7,8],[8,3]];
    mems.forEach(([a,b])=>members.push({a,b,force:null}));
    nodes[0].support='pin'; nodes[3].support='roller';
    nodes[1].loads=[{mag:20,ang:270}]; nodes[2].loads=[{mag:20,ang:270}];
  }

  updateStats();
  draw();
}

// initial
setMode('node');
updateStats();

// auto load a Warren truss to start
setTimeout(()=>loadPreset('warren'),300);
</script>
</body>
</html>